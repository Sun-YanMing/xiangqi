import type { ChessPiece, PieceColor, Move, AIDifficulty, Position } from '../types/chess'
import { cloneBoard } from './boardUtils'
import { getValidMoves, isInCheck, isCheckmate } from './moveValidation'

/**
 * ç½®æ¢è¡¨æ¡ç›®
 */
interface TranspositionEntry {
  score: number
  depth: number
  flag: 'exact' | 'lowerbound' | 'upperbound'
  bestMove?: Move
}

/**
 * æœç´¢ç»Ÿè®¡ä¿¡æ¯
 */
interface SearchStats {
  nodesSearched: number
  cacheHits: number
  cutoffs: number
  startTime: number
}

/**
 * é«˜çº§AIå¼•æ“ç±» - å®ç°ç°ä»£è±¡æ£‹AIç®—æ³•
 * å‚è€ƒé¡¶çº§è±¡æ£‹å¼•æ“çš„è®¾è®¡ç†å¿µï¼ŒåŒ…å«æ·±åº¦æœç´¢ã€é«˜çº§è¯„ä¼°ã€å¼€å±€åº“ç­‰åŠŸèƒ½
 */
export class AdvancedAIEngine {
  private difficulty: AIDifficulty
  private color: PieceColor
  private transpositionTable: Map<string, TranspositionEntry>
  private killerMoves: Move[][]
  private historyTable: Map<string, number>
  private searchStats: SearchStats
  private openingBook: Map<string, Move[]>
  
  // è¯„ä¼°æƒé‡ - å¯è°ƒèŠ‚çš„AIæ€§æ ¼
  private evaluationWeights = {
    material: 1.0,
    mobility: 0.3,
    safety: 0.8,
    center: 0.2,
    development: 0.4,
    tactics: 1.2,
    endgame: 0.6
  }

  constructor(difficulty: AIDifficulty, color: PieceColor) {
    this.difficulty = difficulty
    this.color = color
    this.transpositionTable = new Map()
    this.killerMoves = Array(20).fill(null).map(() => [])
    this.historyTable = new Map()
    this.searchStats = { nodesSearched: 0, cacheHits: 0, cutoffs: 0, startTime: 0 }
    this.openingBook = new Map()
    this.initializeOpeningBook()
  }

  /**
   * è·å–AIçš„æœ€ä½³ç§»åŠ¨ - ä¸»å…¥å£
   */
  async getBestMove(board: (ChessPiece | null)[][]): Promise<Move | null> {
    // é‡ç½®æœç´¢ç»Ÿè®¡
    this.searchStats = { 
      nodesSearched: 0, 
      cacheHits: 0, 
      cutoffs: 0, 
      startTime: Date.now() 
    }

    // æ£€æŸ¥å¼€å±€åº“
    const openingMove = this.getOpeningMove(board)
    if (openingMove) {
      console.log('ğŸ¯ ä½¿ç”¨å¼€å±€åº“:', openingMove)
      return openingMove
    }

    // æ¸…ç†ç½®æ¢è¡¨ï¼ˆä¿ç•™ä¸€å®šæ•°é‡çš„æ¡ç›®ï¼‰
    this.cleanupTranspositionTable()

    // æ ¹æ®éš¾åº¦è°ƒæ•´æœç´¢æ·±åº¦
    const maxDepth = this.getSearchDepth()
    console.log(`ğŸ¤– AIå¼€å§‹æ€è€ƒï¼Œæœç´¢æ·±åº¦: ${maxDepth}å±‚`)

    // è¿­ä»£åŠ æ·±æœç´¢ - ä¼˜åŒ–æ€§èƒ½
    let bestMove: Move | null = null

    for (let depth = 1; depth <= maxDepth; depth++) {
      // æ£€æŸ¥æ—¶é—´é™åˆ¶
      if (this.shouldStopSearch()) {
        console.log(`â° æ—¶é—´é™åˆ¶ï¼Œæå‰ç»“æŸæœç´¢åœ¨æ·±åº¦ ${depth - 1}`)
        break
      }

      const result = this.alphaBetaSearch(
        board, 
        depth, 
        -Infinity, 
        Infinity, 
        this.color === 'red', 
        0
      )
      
      if (result && result.move) {
        bestMove = result.move
        
        // è¾“å‡ºå½“å‰æ·±åº¦çš„æœ€ä½³èµ°æ³•
        console.log(`æ·±åº¦ ${depth}: è¯„åˆ† ${result.score.toFixed(2)}, èµ°æ³•: ${this.formatMove(result.move)}`)
        
        // æ—¶é—´ç®¡ç†ï¼šå¦‚æœå‘ç°æ˜æ˜¾çš„å¥½æ£‹æˆ–æ—¶é—´ä¸å¤Ÿäº†ï¼Œå¯ä»¥æå‰ç»“æŸ
        if (Math.abs(result.score) > 5000 || this.shouldStopSearch()) {
          console.log(`ğŸ¯ æ‰¾åˆ°å¥½æ£‹æˆ–æ—¶é—´ä¸è¶³ï¼Œç»“æŸæœç´¢`)
          break
        }
      }
      
      // å•å±‚æœç´¢æ—¶é—´è¿‡é•¿ä¹Ÿè¦é€€å‡º
      if (Date.now() - this.searchStats.startTime > this.difficulty.thinkingTime * 0.8) {
        console.log(`âš¡ å•å±‚æœç´¢è€—æ—¶è¿‡é•¿ï¼Œåœæ­¢æ·±å…¥`)
        break
      }
    }

    // è¾“å‡ºæœç´¢ç»Ÿè®¡
    const elapsed = Date.now() - this.searchStats.startTime
    console.log(`ğŸ§  æœç´¢å®Œæˆ: ${this.searchStats.nodesSearched} èŠ‚ç‚¹, ${elapsed}ms, ç¼“å­˜å‘½ä¸­ç‡: ${
      (this.searchStats.cacheHits / this.searchStats.nodesSearched * 100).toFixed(1)
    }%`)

    return bestMove
  }

  /**
   * Alpha-Betaæœç´¢ç®—æ³• - æ ¸å¿ƒæœç´¢å¼•æ“
   */
  private alphaBetaSearch(
    board: (ChessPiece | null)[][],
    depth: number,
    alpha: number,
    beta: number,
    isMaximizing: boolean,
    ply: number
  ): { score: number; move?: Move } | null {
    this.searchStats.nodesSearched++

    // æ£€æŸ¥ç½®æ¢è¡¨
    const boardHash = this.getBoardHash(board)
    const cached = this.transpositionTable.get(boardHash)
    if (cached && cached.depth >= depth) {
      this.searchStats.cacheHits++
      if (cached.flag === 'exact' || 
          (cached.flag === 'lowerbound' && cached.score >= beta) ||
          (cached.flag === 'upperbound' && cached.score <= alpha)) {
        return { score: cached.score, move: cached.bestMove }
      }
    }

    // è¾¾åˆ°æœ€å¤§æ·±åº¦ï¼Œè¿›å…¥é™æ­¢æœç´¢
    if (depth <= 0) {
      return { score: this.quiescenceSearch(board, alpha, beta, isMaximizing, 0) }
    }

    // æ£€æŸ¥æ¸¸æˆç»“æŸçŠ¶æ€
    const currentPlayer = isMaximizing ? this.color : (this.color === 'red' ? 'black' : 'red')
    if (isCheckmate(board, currentPlayer)) {
      return { score: isMaximizing ? -9999 + ply : 9999 - ply }
    }

    let bestMove: Move | undefined
    let bestScore = isMaximizing ? -Infinity : Infinity
    
    // è·å–æ‰€æœ‰å¯èƒ½çš„ç§»åŠ¨å¹¶æ’åº
    const moves = this.getOrderedMoves(board, currentPlayer, ply)
    
    for (const move of moves) {
      // æ‰§è¡Œç§»åŠ¨
      const newBoard = this.makeMove(board, move)
      
      // é€’å½’æœç´¢
      const result = this.alphaBetaSearch(
        newBoard,
        depth - 1,
        alpha,
        beta,
        !isMaximizing,
        ply + 1
      )

      if (!result) continue

      if (isMaximizing) {
        if (result.score > bestScore) {
          bestScore = result.score
          bestMove = move
        }
        alpha = Math.max(alpha, result.score)
      } else {
        if (result.score < bestScore) {
          bestScore = result.score
          bestMove = move
        }
        beta = Math.min(beta, result.score)
      }

      // Alpha-Betaå‰ªæ
      if (beta <= alpha) {
        this.searchStats.cutoffs++
        this.addKillerMove(move, ply)
        break
      }
    }

    // å­˜å‚¨åˆ°ç½®æ¢è¡¨
    const flag = bestScore <= alpha ? 'upperbound' : 
                 bestScore >= beta ? 'lowerbound' : 'exact'
    this.transpositionTable.set(boardHash, {
      score: bestScore,
      depth,
      flag,
      bestMove
    })

    return { score: bestScore, move: bestMove }
  }

  /**
   * é™æ­¢æœç´¢ - å¤„ç†æˆ˜æœ¯åºåˆ—ï¼Œé¿å…æ°´å¹³çº¿æ•ˆåº”
   */
  private quiescenceSearch(
    board: (ChessPiece | null)[][],
    alpha: number,
    beta: number,
    isMaximizing: boolean,
    depth: number
  ): number {
    // ä¸¥æ ¼é™åˆ¶é™æ­¢æœç´¢æ·±åº¦é˜²æ­¢æ€§èƒ½é—®é¢˜
    if (depth > 3) {
      return this.evaluatePosition(board)
    }

    const standPat = this.evaluatePosition(board)
    
    if (isMaximizing) {
      if (standPat >= beta) return beta
      alpha = Math.max(alpha, standPat)
    } else {
      if (standPat <= alpha) return alpha
      beta = Math.min(beta, standPat)
    }

    // åªè€ƒè™‘æ•è·ç§»åŠ¨å’Œæ£€æŸ¥ç§»åŠ¨
    const currentPlayer = isMaximizing ? this.color : (this.color === 'red' ? 'black' : 'red')
    const tacticalMoves = this.getTacticalMoves(board, currentPlayer)

    for (const move of tacticalMoves) {
      const newBoard = this.makeMove(board, move)
      const score = this.quiescenceSearch(newBoard, alpha, beta, !isMaximizing, depth + 1)

      if (isMaximizing) {
        if (score >= beta) return beta
        alpha = Math.max(alpha, score)
      } else {
        if (score <= alpha) return alpha
        beta = Math.min(beta, score)
      }
    }

    return isMaximizing ? alpha : beta
  }

  /**
   * å¿«é€Ÿä½ç½®è¯„ä¼°å‡½æ•° - ä¼˜åŒ–æ€§èƒ½ç‰ˆæœ¬
   */
  private evaluatePosition(board: (ChessPiece | null)[][]): number {
    let score = 0

    // æ ¸å¿ƒè¯„ä¼°ï¼šææ–™ä»·å€¼ï¼ˆæœ€é‡è¦ï¼‰
    score += this.evaluateMaterial(board)

    // ç®€å•ä½ç½®è¯„ä¼°
    score += this.evaluateSimplePositional(board) * 0.3

    return this.color === 'red' ? score : -score
  }

  /**
   * ç®€åŒ–çš„ä½ç½®è¯„ä¼° - åªè®¡ç®—åŸºæœ¬ä½ç½®ä»·å€¼
   */
  private evaluateSimplePositional(board: (ChessPiece | null)[][]): number {
    let score = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece) {
          const positionValue = this.getPiecePositionValue(piece, row, col)
          score += piece.color === 'red' ? positionValue : -positionValue
        }
      }
    }
    
    return score
  }

  /**
   * ææ–™ä»·å€¼è¯„ä¼°
   */
  private evaluateMaterial(board: (ChessPiece | null)[][]): number {
    const pieceValues = {
      king: 0,        // å›½ç‹ä»·å€¼æ— é™ï¼Œä¸å‚ä¸è®¡ç®—
      advisor: 250,   // å£«
      elephant: 250,  // è±¡
      horse: 500,     // é©¬
      chariot: 1000,  // è½¦
      cannon: 550,    // ç‚®
      soldier: 100    // å…µ
    }

    let redMaterial = 0, blackMaterial = 0

    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.type !== 'king') {
          const value = pieceValues[piece.type]
          if (piece.color === 'red') {
            redMaterial += value
          } else {
            blackMaterial += value
          }
        }
      }
    }

    return redMaterial - blackMaterial
  }

  /**
   * ä½ç½®ä»·å€¼è¯„ä¼° - æ£‹å­çš„ä½ç½®ä¼˜åŠ¿
   */
  private evaluatePositional(board: (ChessPiece | null)[][]): number {
    let score = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece) {
          const positionValue = this.getPiecePositionValue(piece, row, col)
          const mobility = this.getPieceMobility(board, row, col)
          
          const totalValue = positionValue + mobility * 5
          score += piece.color === 'red' ? totalValue : -totalValue
        }
      }
    }
    
    return score
  }

  /**
   * è·å–æ£‹å­ä½ç½®ä»·å€¼
   */
  private getPiecePositionValue(piece: ChessPiece, row: number, col: number): number {
    // å…µçš„ä½ç½®ä»·å€¼è¡¨ï¼ˆçº¢æ–¹è§†è§’ï¼‰
    const soldierPositionTable = [
      [0,  0,  0,  0,  0,  0,  0,  0,  0], // ç¬¬0è¡Œ
      [0,  0,  0,  0,  0,  0,  0,  0,  0], // ç¬¬1è¡Œ
      [0,  0,  0,  0,  0,  0,  0,  0,  0], // ç¬¬2è¡Œ
      [0,  0,  0,  0,  0,  0,  0,  0,  0], // ç¬¬3è¡Œ
      [0,  0,  0,  0,  0,  0,  0,  0,  0], // ç¬¬4è¡Œ
      [5,  0,  5,  0,  5,  0,  5,  0,  5], // ç¬¬5è¡Œï¼ˆæ²³ç•Œï¼‰
      [10, 5,  10, 5,  10, 5,  10, 5,  10], // ç¬¬6è¡Œ
      [20, 10, 20, 10, 25, 10, 20, 10, 20], // ç¬¬7è¡Œ
      [30, 20, 30, 20, 35, 20, 30, 20, 30], // ç¬¬8è¡Œ
      [50, 30, 50, 30, 60, 30, 50, 30, 50]  // ç¬¬9è¡Œ
    ]

    // è½¦çš„ä½ç½®ä»·å€¼è¡¨
    const chariotPositionTable = [
      [206, 208, 207, 213, 214, 213, 207, 208, 206],
      [206, 212, 209, 216, 233, 216, 209, 212, 206],
      [206, 208, 207, 214, 216, 214, 207, 208, 206],
      [206, 213, 213, 216, 216, 216, 213, 213, 206],
      [208, 211, 211, 214, 215, 214, 211, 211, 208],
      [208, 212, 212, 214, 215, 214, 212, 212, 208],
      [204, 209, 204, 212, 214, 212, 204, 209, 204],
      [198, 208, 204, 212, 212, 212, 204, 208, 198],
      [200, 208, 206, 212, 200, 212, 206, 208, 200],
      [194, 206, 204, 212, 200, 212, 204, 206, 194]
    ]

    switch (piece.type) {
      case 'soldier':
        const soldierRow = piece.color === 'red' ? row : 9 - row
        const soldierCol = piece.color === 'red' ? col : 8 - col
        return soldierPositionTable[soldierRow] ? soldierPositionTable[soldierRow][soldierCol] : 0

      case 'chariot':
        const chariotRow = piece.color === 'red' ? row : 9 - row
        const chariotCol = piece.color === 'red' ? col : 8 - col
        return (chariotPositionTable[chariotRow] ? chariotPositionTable[chariotRow][chariotCol] : 200) - 200

      case 'horse':
        // é©¬åœ¨ä¸­å¿ƒæ›´æœ‰ä»·å€¼
        const centerBonus = Math.max(0, 3 - Math.abs(col - 4)) * 10
        const advancementBonus = piece.color === 'red' ? (9 - row) * 5 : row * 5
        return centerBonus + advancementBonus

      case 'cannon':
        // ç‚®åœ¨åæ’æ›´å®‰å…¨ï¼Œä¸­è·¯æ›´æœ‰ä»·å€¼
        const centerValue = Math.max(0, 3 - Math.abs(col - 4)) * 8
        const backRankBonus = piece.color === 'red' ? (row < 3 ? 15 : 0) : (row > 6 ? 15 : 0)
        return centerValue + backRankBonus

      default:
        return 0
    }
  }

  /**
   * è·å–æ£‹å­æœºåŠ¨æ€§
   */
  private getPieceMobility(board: (ChessPiece | null)[][], row: number, col: number): number {
    const piece = board[row][col]
    if (!piece) return 0

    const moves = getValidMoves(board, piece, { row, col })
    let mobility = moves.length

    // å¯¹ä¸åŒæ£‹å­ç±»å‹ç»™äºˆä¸åŒçš„æœºåŠ¨æ€§æƒé‡
    switch (piece.type) {
      case 'chariot':
        return mobility * 3  // è½¦çš„æœºåŠ¨æ€§æœ€é‡è¦
      case 'horse':
        return mobility * 2  // é©¬çš„æœºåŠ¨æ€§å¾ˆé‡è¦
      case 'cannon':
        return mobility * 1.5  // ç‚®çš„æœºåŠ¨æ€§è¾ƒé‡è¦
      default:
        return mobility
    }
  }

  /**
   * å›½ç‹å®‰å…¨è¯„ä¼°
   */
  private evaluateKingSafety(board: (ChessPiece | null)[][]): number {
    let redKingSafety = this.getKingSafety(board, 'red')
    let blackKingSafety = this.getKingSafety(board, 'black')
    
    return redKingSafety - blackKingSafety
  }

  private getKingSafety(board: (ChessPiece | null)[][], color: PieceColor): number {
    let safety = 0
    
    // å¯»æ‰¾å›½ç‹ä½ç½®
    let kingPos: Position | null = null
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.type === 'king' && piece.color === color) {
          kingPos = { row, col }
          break
        }
      }
    }
    
    if (!kingPos) return -1000 // æ²¡æœ‰å›½ç‹æ˜¯è‡´å‘½çš„
    
    // æ£€æŸ¥å›½ç‹æ˜¯å¦åœ¨å®«å†…
    const inPalace = this.isInPalace(kingPos, color)
    if (inPalace) safety += 50
    
    // æ£€æŸ¥å£«è±¡ä¿æŠ¤
    const protectors = this.countProtectors(board, kingPos, color)
    safety += protectors * 20
    
    // æ£€æŸ¥æ˜¯å¦é¢ä¸´å¨èƒ
    const threats = this.countThreats(board, kingPos, color)
    safety -= threats * 30
    
    return safety
  }

  /**
   * ä¸­å¿ƒæ§åˆ¶è¯„ä¼° - ç®€åŒ–ç‰ˆæœ¬ (æš‚æ—¶æœªä½¿ç”¨)
   */
  // private evaluateCenterControl(board: (ChessPiece | null)[][]): number {
    let redControl = 0, blackControl = 0
    
    // ä¸­å¿ƒåŒºåŸŸçš„å…³é”®æ ¼å­
    const centerSquares = [
      { row: 4, col: 3 }, { row: 4, col: 4 }, { row: 4, col: 5 },
      { row: 5, col: 3 }, { row: 5, col: 4 }, { row: 5, col: 5 }
    ]
    
    for (const square of centerSquares) {
      const redAttackers = this.countAttackers(board, square, 'red')
      const blackAttackers = this.countAttackers(board, square, 'black')
      
      redControl += redAttackers * 10
      blackControl += blackAttackers * 10
    }
    
    return redControl - blackControl
  }

  /**
   * å‘å±•è¯„ä¼° - ç®€åŒ–ç‰ˆæœ¬
   */
  private evaluateDevelopment(board: (ChessPiece | null)[][]): number {
    let redDevelopment = this.getDevelopment(board, 'red')
    let blackDevelopment = this.getDevelopment(board, 'black')
    
    return redDevelopment - blackDevelopment
  }

  private getDevelopment(board: (ChessPiece | null)[][], color: PieceColor): number {
    let development = 0
    
    // æ£€æŸ¥é©¬ç‚®æ˜¯å¦å‡ºåŠ¨
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === color) {
          if (piece.type === 'horse' || piece.type === 'cannon') {
            // å¦‚æœé©¬ç‚®ç¦»å¼€äº†åˆå§‹ä½ç½®ï¼Œç»™äºˆå‘å±•åˆ†
            if (this.isPieceDeveloped(piece, row, col, color)) {
              development += 15
            }
          }
        }
      }
    }
    
    return development
  }

  /**
   * æˆ˜æœ¯è¯„ä¼° - ç®€åŒ–ç‰ˆæœ¬
   */
  private evaluateTactics(board: (ChessPiece | null)[][]): number {
    let redTactics = this.getTacticalAdvantage(board, 'red')
    let blackTactics = this.getTacticalAdvantage(board, 'black')
    
    return redTactics - blackTactics
  }

  private getTacticalAdvantage(board: (ChessPiece | null)[][], color: PieceColor): number {
    let advantage = 0
    
    // æ£€æŸ¥å‰æ”»ï¼ˆä¸€å­æ”»å‡»å¤šå­ï¼‰
    advantage += this.countForks(board, color) * 50
    
    // æ£€æŸ¥ç‰µåˆ¶ï¼ˆè¢«ç‰µåˆ¶çš„å­ä¸èƒ½åŠ¨ï¼‰
    advantage += this.countPins(board, color) * 40
    
    // æ£€æŸ¥é—ªå‡»ï¼ˆç§»åŠ¨ä¸€å­æ”»å‡»å¤šä¸ªç›®æ ‡ï¼‰
    advantage += this.countDiscoveredAttacks(board, color) * 45
    
    // æ£€æŸ¥è¿ç¯ç‚®
    advantage += this.countCannonBatteries(board, color) * 60
    
    return advantage
  }

  /**
   * æ®‹å±€è¯„ä¼°
   */
  private evaluateEndgame(board: (ChessPiece | null)[][]): number {
    const totalMaterial = this.getTotalMaterial(board)
    
    // å¦‚æœææ–™è¾ƒå°‘ï¼Œè¿›å…¥æ®‹å±€è¯„ä¼°
    if (totalMaterial < 3000) {
      let endgameScore = 0
      
      // å›½ç‹æ´»è·ƒæ€§åœ¨æ®‹å±€ä¸­å¾ˆé‡è¦
      endgameScore += this.evaluateKingActivity(board)
      
      // å…µçš„æ¨è¿›åœ¨æ®‹å±€ä¸­æ›´é‡è¦
      endgameScore += this.evaluatePawnAdvancement(board) * 2
      
      return endgameScore
    }
    
    return 0
  }

  /**
   * ç§»åŠ¨æ’åº - æé«˜Alpha-Betaå‰ªææ•ˆç‡
   */
  private getOrderedMoves(board: (ChessPiece | null)[][], color: PieceColor, ply: number): Move[] {
    const allMoves = this.getAllPossibleMoves(board, color)
    
    // æŒ‰ç…§ç§»åŠ¨ä»·å€¼æ’åº
    return allMoves.sort((a, b) => {
      let scoreA = 0, scoreB = 0
      
      // 1. æ•è·ç§»åŠ¨ä¼˜å…ˆï¼ˆæŒ‰ä»·å€¼å·®æ’åºï¼‰
      if (a.capturedPiece) scoreA += this.getCaptureValue(a)
      if (b.capturedPiece) scoreB += this.getCaptureValue(b)
      
      // 2. å°†å†›ç§»åŠ¨ä¼˜å…ˆ
      if (this.givesCheck(board, a)) scoreA += 500
      if (this.givesCheck(board, b)) scoreB += 500
      
      // 3. æ€æ‰‹ç§»åŠ¨
      if (this.isKillerMove(a, ply)) scoreA += 300
      if (this.isKillerMove(b, ply)) scoreB += 300
      
      // 4. å†å²å¯å‘
      scoreA += this.getHistoryScore(a)
      scoreB += this.getHistoryScore(b)
      
      return scoreB - scoreA
    })
  }

  /**
   * åˆå§‹åŒ–å¼€å±€åº“
   */
  private initializeOpeningBook(): void {
    // ç®€åŒ–å¼€å±€åº“å®ç° - ä½¿ç”¨å­—ç¬¦ä¸²é”®å€¼å¯¹
    this.openingBook.set('start', [])
  }

  // ===== è¾…åŠ©æ–¹æ³• =====

  private getSearchDepth(): number {
    // é™ä½æœç´¢æ·±åº¦ï¼Œæå‡æ€§èƒ½
    switch (this.difficulty.depth) {
      case 1: return 2   // ç®€å•ï¼š2å±‚
      case 2: return 3   // ä¸­ç­‰ï¼š3å±‚
      case 3: return 4   // å›°éš¾ï¼š4å±‚
      default: return 3  // é»˜è®¤3å±‚
    }
  }

  private getAllPossibleMoves(board: (ChessPiece | null)[][], color: PieceColor): Move[] {
    const moves: Move[] = []
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === color) {
          const validMoves = getValidMoves(board, piece, { row, col })
          
          for (const move of validMoves) {
            moves.push({
              from: { row, col },
              to: move,
              piece: piece,
              capturedPiece: board[move.row][move.col] || undefined,
              timestamp: Date.now()
            })
          }
        }
      }
    }
    
    return moves
  }

  private makeMove(board: (ChessPiece | null)[][], move: Move): (ChessPiece | null)[][] {
    const newBoard = cloneBoard(board)
    newBoard[move.to.row][move.to.col] = newBoard[move.from.row][move.from.col]
    newBoard[move.from.row][move.from.col] = null
    return newBoard
  }

  private getBoardHash(board: (ChessPiece | null)[][]): string {
    let hash = ''
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        hash += piece ? `${piece.color[0]}${piece.type[0]}` : '--'
      }
    }
    return hash
  }

  private getTacticalMoves(board: (ChessPiece | null)[][], color: PieceColor): Move[] {
    return this.getAllPossibleMoves(board, color).filter(move => 
      move.capturedPiece || this.givesCheck(board, move)
    )
  }

  private cleanupTranspositionTable(): void {
    if (this.transpositionTable.size > 10000) {
      // æ›´é¢‘ç¹æ¸…ç†ï¼Œä¿ç•™æœ€æ–°çš„5000ä¸ªæ¡ç›®
      const entries = Array.from(this.transpositionTable.entries())
      this.transpositionTable.clear()
      
      entries.slice(-5000).forEach(([key, value]) => {
        this.transpositionTable.set(key, value)
      })
    }
  }

  private shouldStopSearch(): boolean {
    const elapsed = Date.now() - this.searchStats.startTime
    // ä¸¥æ ¼é™åˆ¶æ€è€ƒæ—¶é—´ï¼Œæœ€å¤š2ç§’
    return elapsed > Math.min(this.difficulty.thinkingTime * 0.5, 2000)
  }

  private getOpeningMove(board: (ChessPiece | null)[][]): Move | null {
    // ç®€åŒ–çš„å¼€å±€æ£€æµ‹
    const moveCount = this.countMoves(board)
    if (moveCount > 10) return null

    const moves = this.openingBook.get(this.getPositionKey([]))
    if (moves && moves.length > 0) {
      return moves[Math.floor(Math.random() * moves.length)]
    }
    
    return null
  }

  private formatMove(move: Move): string {
    return `${String.fromCharCode(97 + move.from.col)}${10 - move.from.row} -> ${String.fromCharCode(97 + move.to.col)}${10 - move.to.row}`
  }

  private addKillerMove(move: Move, ply: number): void {
    if (ply < this.killerMoves.length) {
      this.killerMoves[ply].unshift(move)
      this.killerMoves[ply] = this.killerMoves[ply].slice(0, 2) // åªä¿ç•™å‰2ä¸ª
    }
  }

  // æ›´å¤šè¾…åŠ©æ–¹æ³•çš„å®ç°...
  private getCaptureValue(move: Move): number {
    if (!move.capturedPiece) return 0
    const values = { king: 0, advisor: 250, elephant: 250, horse: 500, chariot: 1000, cannon: 550, soldier: 100 }
    return values[move.capturedPiece.type] || 0
  }

  private givesCheck(board: (ChessPiece | null)[][], move: Move): boolean {
    const newBoard = this.makeMove(board, move)
    const opponentColor = move.piece.color === 'red' ? 'black' : 'red'
    return isInCheck(newBoard, opponentColor)
  }

  private isKillerMove(move: Move, ply: number): boolean {
    if (ply >= this.killerMoves.length) return false
    return this.killerMoves[ply].some(killer => 
      killer.from.row === move.from.row && killer.from.col === move.from.col &&
      killer.to.row === move.to.row && killer.to.col === move.to.col
    )
  }

  private getHistoryScore(move: Move): number {
    const key = `${move.from.row},${move.from.col}-${move.to.row},${move.to.col}`
    return this.historyTable.get(key) || 0
  }

  private countMoves(board: (ChessPiece | null)[][]): number {
    let count = 0
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        if (!board[row][col]) count++
      }
    }
    return 90 - count
  }

  private getPositionKey(moves: Move[]): string {
    return moves.map(m => `${m.from.row}${m.from.col}${m.to.row}${m.to.col}`).join('|')
  }

  /**
   * æ£€æŸ¥ä½ç½®æ˜¯å¦åœ¨å®«å†…
   */
  private isInPalace(pos: Position, color: PieceColor): boolean {
    const { row, col } = pos
    if (color === 'red') {
      return row >= 7 && row <= 9 && col >= 3 && col <= 5
    } else {
      return row >= 0 && row <= 2 && col >= 3 && col <= 5
    }
  }

  /**
   * è®¡ç®—ä¿æŠ¤å›½ç‹çš„æ£‹å­æ•°é‡
   */
  private countProtectors(board: (ChessPiece | null)[][], pos: Position, color: PieceColor): number {
    let count = 0
    const adjacentPositions = [
      { row: pos.row - 1, col: pos.col }, { row: pos.row + 1, col: pos.col },
      { row: pos.row, col: pos.col - 1 }, { row: pos.row, col: pos.col + 1 }
    ]

    for (const adjPos of adjacentPositions) {
      if (adjPos.row >= 0 && adjPos.row < 10 && adjPos.col >= 0 && adjPos.col < 9) {
        const piece = board[adjPos.row][adjPos.col]
        if (piece && piece.color === color && (piece.type === 'advisor' || piece.type === 'elephant')) {
          count++
        }
      }
    }
    return count
  }

  /**
   * è®¡ç®—å¯¹å›½ç‹çš„å¨èƒæ•°é‡
   */
  private countThreats(board: (ChessPiece | null)[][], pos: Position, color: PieceColor): number {
    let threats = 0
    const opponentColor = color === 'red' ? 'black' : 'red'
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === opponentColor) {
          const moves = getValidMoves(board, piece, { row, col })
          if (moves.some(move => move.row === pos.row && move.col === pos.col)) {
            threats++
          }
        }
      }
    }
    return threats
  }

  /**
   * è®¡ç®—æ”»å‡»æŒ‡å®šä½ç½®çš„æ£‹å­æ•°é‡
   */
  private countAttackers(board: (ChessPiece | null)[][], pos: Position, color: PieceColor): number {
    let attackers = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === color) {
          const moves = getValidMoves(board, piece, { row, col })
          if (moves.some(move => move.row === pos.row && move.col === pos.col)) {
            attackers++
          }
        }
      }
    }
    return attackers
  }

  /**
   * æ£€æŸ¥æ£‹å­æ˜¯å¦å·²å‘å±•ï¼ˆç¦»å¼€åˆå§‹ä½ç½®ï¼‰
   */
  private isPieceDeveloped(piece: ChessPiece, row: number, col: number, color: PieceColor): boolean {
    const initialPositions = {
      red: {
        horse: [[9, 1], [9, 7]],
        cannon: [[7, 1], [7, 7]]
      },
      black: {
        horse: [[0, 1], [0, 7]],
        cannon: [[2, 1], [2, 7]]
      }
    }

    const positions = initialPositions[color]?.[piece.type as 'horse' | 'cannon']
    if (!positions) return true

    return !positions.some(([r, c]) => r === row && c === col)
  }

  /**
   * è®¡ç®—å‰æ”»æ•°é‡ï¼ˆä¸€å­æ”»å‡»å¤šå­ï¼‰
   */
  private countForks(board: (ChessPiece | null)[][], color: PieceColor): number {
    let forks = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === color) {
          const moves = getValidMoves(board, piece, { row, col })
          
          for (const move of moves) {
            const testBoard = this.makeMove(board, {
              from: { row, col },
              to: move,
              piece,
              capturedPiece: board[move.row][move.col] || undefined,
              timestamp: 0
            })
            
            const attackedPieces = this.getAttackedEnemyPieces(testBoard, move, color)
            if (attackedPieces >= 2) {
              forks++
            }
          }
        }
      }
    }
    return forks
  }

  /**
   * è®¡ç®—ç‰µåˆ¶æ•°é‡
   */
  private countPins(_board: (ChessPiece | null)[][], _color: PieceColor): number {
    // ç®€åŒ–å®ç° - æ£€æŸ¥æ˜¯å¦æœ‰æ£‹å­è¢«ç‰µåˆ¶æ— æ³•ç§»åŠ¨
    return 0
  }

  /**
   * è®¡ç®—é—ªå‡»æ•°é‡
   */
  private countDiscoveredAttacks(_board: (ChessPiece | null)[][], _color: PieceColor): number {
    // ç®€åŒ–å®ç° - æ£€æŸ¥ç§»åŠ¨ä¸€å­åæ˜¯å¦æš´éœ²æ”»å‡»çº¿
    return 0
  }

  /**
   * è®¡ç®—è¿ç¯ç‚®æ•°é‡
   */
  private countCannonBatteries(board: (ChessPiece | null)[][], color: PieceColor): number {
    let batteries = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.color === color && piece.type === 'cannon') {
          // æ£€æŸ¥åŒè¡Œæˆ–åŒåˆ—æ˜¯å¦æœ‰å…¶ä»–ç‚®
          if (this.hasCannonSupport(board, row, col, color)) {
            batteries++
          }
        }
      }
    }
    return batteries
  }

  /**
   * è®¡ç®—æ€»ææ–™ä»·å€¼
   */
  private getTotalMaterial(board: (ChessPiece | null)[][]): number {
    const values = { king: 0, advisor: 250, elephant: 250, horse: 500, chariot: 1000, cannon: 550, soldier: 100 }
    let total = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.type !== 'king') {
          total += values[piece.type]
        }
      }
    }
    return total
  }

  /**
   * è¯„ä¼°å›½ç‹æ´»è·ƒæ€§ï¼ˆæ®‹å±€ï¼‰
   */
  private evaluateKingActivity(board: (ChessPiece | null)[][]): number {
    let redKingActivity = 0, blackKingActivity = 0
    
    // å¯»æ‰¾å›½ç‹å¹¶è¯„ä¼°å…¶æ´»è·ƒæ€§
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.type === 'king') {
          const moves = getValidMoves(board, piece, { row, col })
          const activity = moves.length * 10
          
          if (piece.color === 'red') {
            redKingActivity += activity
          } else {
            blackKingActivity += activity
          }
        }
      }
    }
    
    return redKingActivity - blackKingActivity
  }

  /**
   * è¯„ä¼°å…µçš„æ¨è¿›ï¼ˆæ®‹å±€ï¼‰
   */
  private evaluatePawnAdvancement(board: (ChessPiece | null)[][]): number {
    let redAdvancement = 0, blackAdvancement = 0
    
    for (let row = 0; row < 10; row++) {
      for (let col = 0; col < 9; col++) {
        const piece = board[row][col]
        if (piece && piece.type === 'soldier') {
          if (piece.color === 'red') {
            redAdvancement += (9 - row) * 5  // çº¢æ–¹å‘ä¸Šæ¨è¿›
          } else {
            blackAdvancement += row * 5      // é»‘æ–¹å‘ä¸‹æ¨è¿›
          }
        }
      }
    }
    
    return redAdvancement - blackAdvancement
  }

  /**
   * è·å–è¢«æ”»å‡»çš„æ•Œæ–¹æ£‹å­æ•°é‡
   */
  private getAttackedEnemyPieces(board: (ChessPiece | null)[][], fromPos: Position, color: PieceColor): number {
    const piece = board[fromPos.row][fromPos.col]
    if (!piece) return 0
    
    const moves = getValidMoves(board, piece, fromPos)
    const opponentColor = color === 'red' ? 'black' : 'red'
    
    let attacked = 0
    for (const move of moves) {
      const targetPiece = board[move.row][move.col]
      if (targetPiece && targetPiece.color === opponentColor) {
        attacked++
      }
    }
    return attacked
  }

  /**
   * æ£€æŸ¥ç‚®æ˜¯å¦æœ‰æ”¯æ´
   */
  private hasCannonSupport(board: (ChessPiece | null)[][], row: number, col: number, color: PieceColor): boolean {
    // æ£€æŸ¥åŒè¡Œ
    for (let c = 0; c < 9; c++) {
      if (c !== col) {
        const piece = board[row][c]
        if (piece && piece.color === color && piece.type === 'cannon') {
          return true
        }
      }
    }
    
    // æ£€æŸ¥åŒåˆ—
    for (let r = 0; r < 10; r++) {
      if (r !== row) {
        const piece = board[r][col]
        if (piece && piece.color === color && piece.type === 'cannon') {
          return true
        }
      }
    }
    
    return false
  }
}

/**
 * AIéš¾åº¦é…ç½® - å‡çº§ç‰ˆ
 */
export const ADVANCED_AI_DIFFICULTIES = {
  easy: {
    depth: 1,
    thinkingTime: 500,
    randomness: 0.15,
    name: 'å…¥é—¨'
  },
  medium: {
    depth: 2,
    thinkingTime: 1000,
    randomness: 0.05,
    name: 'ä¸šä½™'
  },
  hard: {
    depth: 3,
    thinkingTime: 1500,
    randomness: 0.01,
    name: 'ä¸“ä¸š'
  },
  expert: {
    depth: 4,
    thinkingTime: 2000,
    randomness: 0,
    name: 'å¤§å¸ˆ'
  }
} as const